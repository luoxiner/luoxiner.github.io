<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title>volatile 和 可见性 | Hexo</title><meta name="description" content="volatile 和 可见性 - John Doe"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/theme.css"><link rel="search" type="application/opensearchdescription+xml" href="/atom.xml" title="Hexo"><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
</head><body><div class="wrap"><header><h1 class="branding"><a href="/" title="Hexo"><img class="logo-image" src="/logo.png" alt="logo"></a></h1><ul class="nav nav-list"><li class="nav-list-item"><a class="nav-list-link" href="/" target="_self">HOME</a></li><li class="nav-list-item"><a class="nav-list-link" href="/archives" target="_self">ARCHIVES</a></li><li class="nav-list-item"><a class="nav-list-link" href="https://github.com/Dreyer" target="_blank">GITHUB</a></li><li class="nav-list-item"><a class="nav-list-link" href="/atom.xml" target="_self">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">volatile 和 可见性</h1><div class="post-info"><a></a>2021-03-14</div><div class="post-content"><h4 id="代码的执行顺序也许和我们所看到的不一致"><a class="header-anchor" href="#代码的执行顺序也许和我们所看到的不一致">¶</a>代码的执行顺序也许和我们所看到的不一致</h4>
<p>何为一致？</p>
<h3 id="并发中的一致性"><a class="header-anchor" href="#并发中的一致性">¶</a>并发中的一致性</h3>
<ul>
<li>
<p>静态一致性</p>
<p>静态一致性有两个原则：</p>
<ol>
<li>方法调用应该呈现出某种顺序，并且每个时刻只有一个调用在执行。</li>
<li>由一系列静止状态分割开来的方法调用应该呈现出和按照他们的实时调用次序相同的执行效果。</li>
</ol>
<p>首先方法调用可以看作是一段时间间隔，并发实质上就是多个方法调用在时间线上重叠。静态一致性保证，对外而言，两个方法调用总是不会重叠，但是两个调用的先后顺序不能被保证。</p>
<p><strong>未决</strong> 一个方法调用存在调用的请求以及对请求的回复，如果一个方法调用发出了请求但是没有收到回复就成这个方法调用时未决的。</p>
<p><strong>静态对象</strong> 如果一个并发对象不存在未决的方法调用就成这个并发状态为静态的。</p>
<p>对于第二点，是指如果一个对象变为静态的，那么在对象变为静态之前的方法调用先发生于对象静态之后产生的静态调用，一个简单的例子，在某一时刻，两个方法调用A，B在对象上发生，之后AB都得到了回复，此时对象变是静态的（不存在未决的方法调用），之后一段时间来了一个调用C，那么C应该先于AB发生，但是AB之间的顺序是无法确定的。</p>
<p>静态一致性具有复合不变的特性，多个对象上的静态一致性在总体看来也是静态一致的。首先第一点，进行复合显然复合之后依然成立，第二点，任意个整体静态的时刻，所有组成这个整体的对象状态也是静止的，并且总体上的静态之前和之后的操作是由组成整体的单个对象的对映体时间上的操作组成的，显然，这两类操作之间存在先后顺序。</p>
</li>
<li>
<p>顺序一致性</p>
<p>静态一致性太弱了，对于编程来说几乎没有提供什么可靠的保证，我们需要一种更强的顺序保证，最好程序的运行能够按照我们所编写的代码的顺序来运行，而不是看天气。</p>
<p>顺序一致性有两个原则：</p>
<ul>
<li>
<p>方法调用应该呈现出按照程序次序调用的执行结果</p>
</li>
<li>
<p>静态一致性的第一个原则</p>
</li>
</ul>
<p>对于执行方法调用的每一个线程，从线程自己的角度来看，方法调用的执行顺序总是按照程序执行顺序执行的。</p>
<blockquote>
<p>但是，顺序一致性和静态一致性之间没有必然的联系，程序符合顺序一致性但却不一定符合静态一致性，符合静态一致性也不一定符合顺序一致性。原因在于静态一致性的第二个原则，顺序一致性只兼顾了静态一致性的第一个原则。</p>
</blockquote>
<p>顺序一致性不符合复合的规律，多个顺序一致的对象的组合对于整体来说不一定是顺序一致的，多个线程执行的方法调用之间可能相互交叉，对于共享对象本身来说方法调用是按照程序顺序执行的，但是对于整体来说，方法调用的结果也许和整体的执行顺序不相符合，这违背了整体的顺序一致性。</p>
</li>
<li>
<p>可线性化</p>
<p>由于顺序一致性不符合复合的要求，我们需要一种最强的一致性来描述多个顺序一致的执行复合也能满足顺序一致性的模型。</p>
<p>原则：</p>
<ul>
<li>每个方法调用都应该呈现出一种与他的调用和回复之间的某个时刻的行为相同的瞬时效果。</li>
</ul>
<p>简而言之就是方法调用是需要被保持的，后续的方法调用应该能够看到这个方法调用产生的结果。</p>
</li>
</ul>
</div></article></div></main><footer><div class="paginator"><a class="next" href="/2021/03/12/%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%96%87%E4%BB%B6%E5%AD%90%E7%B3%BB%E7%BB%9F/">next</a></div><div class="copyright"><p>&copy; 2021 <a href="https://luoxiner.github.io">John Doe</a>.<br>Powered by <a href="https://hexo.io/" target="_blank">Hexo</a> &amp; <a href="https://github.com/Dreyer/hexo-theme-artemis" target="_blank">Artemis</a>.</p></div></footer></div></body></html>