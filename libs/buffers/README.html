<h1>buffers</h1>
<p>Treat a collection of Buffers as a single contiguous partially mutable Buffer.</p>
<p>Where possible, operations execute without creating a new Buffer and copying<br>
everything over.</p>
<p>This is a cleaner more Buffery rehash of<br>
<a href="http://github.com/substack/node-bufferlist">bufferlist</a>.</p>
<h1>example</h1>
<h2 id="slice"><a class="header-anchor" href="#slice">¶</a>slice</h2>
<pre><code>var Buffers = require('buffers');
var bufs = Buffers();
bufs.push(new Buffer([1,2,3]));
bufs.push(new Buffer([4,5,6,7]));
bufs.push(new Buffer([8,9,10]));

console.dir(bufs.slice(2,8))
</code></pre>
<p>output:</p>
<pre><code>$ node examples/slice.js 
&lt;Buffer 03 04 05 06 07 08&gt;
</code></pre>
<h2 id="splice"><a class="header-anchor" href="#splice">¶</a>splice</h2>
<pre><code>var Buffers = require('buffers');
var bufs = Buffers([
    new Buffer([1,2,3]),
    new Buffer([4,5,6,7]),
    new Buffer([8,9,10]),
]);

var removed = bufs.splice(2, 4);
console.dir({
    removed : removed.slice(),
    bufs : bufs.slice(),
});
</code></pre>
<p>output:</p>
<pre><code>$ node examples/splice.js
{ removed: &lt;Buffer 03 04 05 06&gt;,
  bufs: &lt;Buffer 01 02 07 08 09 0a&gt; }
</code></pre>
<h1>methods</h1>
<h2 id="Buffers-buffers"><a class="header-anchor" href="#Buffers-buffers">¶</a>Buffers(buffers)</h2>
<p>Create a Buffers with an array of <code>Buffer</code>s if specified, else <code>[]</code>.</p>
<h2 id="push-buf1-buf2…"><a class="header-anchor" href="#push-buf1-buf2…">¶</a>.push(buf1, buf2…)</h2>
<p>Push buffers onto the end. Just like <code>Array.prototype.push</code>.</p>
<h2 id="unshift-buf1-buf2…"><a class="header-anchor" href="#unshift-buf1-buf2…">¶</a>.unshift(buf1, buf2…)</h2>
<p>Unshift buffers onto the head. Just like <code>Array.prototype.unshift</code>.</p>
<h2 id="slice-i-j"><a class="header-anchor" href="#slice-i-j">¶</a>.slice(i, j)</h2>
<p>Slice a range out of the buffer collection as if it were contiguous.<br>
Works just like the <code>Array.prototype.slice</code> version.</p>
<h2 id="splice-i-howMany-replacements"><a class="header-anchor" href="#splice-i-howMany-replacements">¶</a>.splice(i, howMany, replacements)</h2>
<p>Splice the buffer collection as if it were contiguous.<br>
Works just like <code>Array.prototype.splice</code>, even the replacement part!</p>
<h2 id="copy-dst-dstStart-start-end"><a class="header-anchor" href="#copy-dst-dstStart-start-end">¶</a>.copy(dst, dstStart, start, end)</h2>
<p>Copy the buffer collection as if it were contiguous to the <code>dst</code> Buffer with the<br>
specified bounds.<br>
Works just like <code>Buffer.prototype.copy</code>.</p>
<h2 id="get-i"><a class="header-anchor" href="#get-i">¶</a>.get(i)</h2>
<p>Get a single element at index <code>i</code>.</p>
<h2 id="set-i-x"><a class="header-anchor" href="#set-i-x">¶</a>.set(i, x)</h2>
<p>Set a single element’s value at index <code>i</code>.</p>
<h2 id="indexOf-needle-offset"><a class="header-anchor" href="#indexOf-needle-offset">¶</a>.indexOf(needle, offset)</h2>
<p>Find a string or buffer <code>needle</code> inside the buffer collection. Returns<br>
the position of the search string or -1 if the search string was not<br>
found.</p>
<p>Provide an <code>offset</code> to skip that number of characters at the beginning<br>
of the search. This can be used to find additional matches.</p>
<p>This function will return the correct result even if the search string<br>
is spread out over multiple internal buffers.</p>
<h2 id="toBuffer"><a class="header-anchor" href="#toBuffer">¶</a>.toBuffer()</h2>
<p>Convert the buffer collection to a single buffer, equivalent with <code>.slice(0, buffers.length)</code>;</p>
<h2 id="toString-encoding-start-end"><a class="header-anchor" href="#toString-encoding-start-end">¶</a>.toString(encoding, start, end)</h2>
<p>Decodes and returns a string from the buffer collection.<br>
Works just like <code>Buffer.prototype.toString</code></p>
